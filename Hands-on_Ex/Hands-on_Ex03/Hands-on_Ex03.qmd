---
title: "Hands-on Exercise 4: Spatial Point Patterns Analysis"
date: "29 january 2023"
date-modified: "`r Sys.Date()`"
number-sections: true
format: html
execute: 
  echo: true
  eval: true
  warning: false
editor: visual
---

## Installing and Loading R packages

```{r}
pacman::p_load(maptools, sf, raster, spatstat, tmap)
```

## Spatial Data Wrangling

```{r}
childcare_sf <- st_read("data/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "data", layer="CostalOutline")
```

```{r}
mpsz_sf <- st_read(dsn = "data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

Using the appropriate **sf** function you learned in Hands-on Exercise 2, retrieve the referencing system information of these geospatial data.

```{r}
st_crs(sg_sf)

st_crs(mpsz_sf)
```

Using the method you learned in Lesson 2, assign the correct crs to mpsz_sf and sg_sf simple feature data frames.

```{r}
sg_sf<-st_transform(sg_sf, crs = 3414)

mpsz_sf<-st_transform(mpsz_sf, crs = 3414)
```

DIY: create map as given

Alternatively, we can prepare a pin map by using the code chunk below. tmap mode is set to view: interactive pin map: allows us to navigate and zoom around the map freely.

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

## Geospatial Data Wrangling

Converting sf data frames to sp's spatial class

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
```

DIY: Using appropriate function, display the information of these three Spatial\* classes as shown below.

```{r}
childcare
mpsz
sg
```

## Converting the Spatial class unto generic sp format

spatstat requires the analytical data in ppp object form

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

```{r}
childcare_sp
sg_sp
```

### Converting the genetic sp format into spatstat's ppp format

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
childcare_ppp
```

plotting childcare_ppp

```{r}
plot(childcare_ppp)
```

Taking a quick look at summary statistics of newly created ppp object

```{r}
summary(childcare_ppp)
```

### Handling duplicated points

Checking for any duplicated objects

```{r}
any(duplicated(childcare_ppp))
```

To count the number of co-indicence points, we use the mutiplicity() function

```{r}
multiplicity(childcare_ppp)
```

Counting the number of duplicated points

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

To view the locations of dupicated point events, plot childcare data by using code below

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)

tmap_mode('plot')
```

Counting duplicates: jittering, adds a small perturbation to the duplicated points so they do not occupy the exact same space

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

Check for any duplicated point in the geospatial data

```{r}
any(duplicated(childcare_ppp_jit))
```

## Creating owin object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.

```{r}
sg_owin <- as(sg_sp, "owin")

plot(sg_owin)
```

```{r}
summary(sg_owin)
```

## Combining point events object and owin object

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]

summary(childcare_ppp)

plot(childcareSG_ppp)
```

## First-order Spatial Point Patterns Analysis

Kernel Density Estimation: the following code chunk computes a kernel density using the following configurations of density of spatstat

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 
```

Display the kernel density derived using plot()

```{r}
plot(kde_childcareSG_bw)
```

Retrieve the bandwidth used to compute kde layer using code chunk

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### Rescaling KDE

rescale() is used to convert the unit of measurement from meter to kilometer

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

then, we re-run density using the rescale data set and plot output kde map

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

Difference from earlier version: data values on the legend

### Working with different automatic bandwidth methods

```{r}
 bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

Comparing the output of using bw.diggle and bw.ppl methods

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### Working with different kernel methods

Computing 3 more kernel density estimations by using these 3 kernel functions

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## Fixed and Adaptive KDE

Compute KDE layer by defining a bandwidth of 600 meter

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

Computing KDE by using adaptive bandwidth

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

Comparing adaptive and fixed kernel density estimation outputs

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

Converting KDE output into grid object

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG.bw)
spplot(gridded_kde_childcareSG_bw)
```

Converting gridded output into raster

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

Looking at properties of kde_childcareSG_bw_raster RasterLayer

```{r}
kde_childcareSG_bw_raster
```

### Assigning projection systems

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

## Visualising the output in tmap

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

## Comparing spatial point patterns using KDE

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

Plotting target planning areas

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
plot(tm, main = "Tampines")
plot(ck, main = "Choa Chu Kang")
plot(jw, main = "Jurong West")
```

Converting the spatial point data frame into generic sp format

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

Creating owin object

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

Combining Childcare points and the study area

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

Next, *rescale()* function is used to trasnform the unit of measurement from metre to kilometre.

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

The code chunk below is used to plot these four study areas and the locations of the childcare centres.

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

Computing KDE

```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

Computing fixed bandwidth KDE

```{r}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

## Nearest Neighbour Analysis

### Testing spatial point patterns using Clarks and Evans Test

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

### Clark and Evans Test: Choa Chu Kang planning area

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

### Clark and Evans Test: Tampines planning area

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```
